 <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Huopa Proxy</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap" rel="stylesheet">

<style>
    body {
      font-family: sans-serif;
      overflow: hidden;
      margin: 0;
      background-color: rgba(25, 25, 25);
      color: white;
    }

    .page {
      width: 100%;
      height: calc(100%);
      position: absolute;
      top: 0;
      left: 0;
      border: none;
      background-color: white;
    }
</style>
</head>
<body>
<script type="module">
    let siteLogs = {}
    let urls = {};
    const url = new URL(window.location.href);
    const params = new URLSearchParams(window.location.search)
    let targetUrl = params.get("start") || "https://www.startpage.com/";
    let selectedTab = 0;
    let newTabId = 1;
    let currentUrl = null;
    let title = targetUrl;
    const serverUrl = params.get("server") || "https://allucat1000-huopaproxy-29.deno.dev/proxy";
    const server = new URL(serverUrl);

    let lastHovered = null;
    let savedColor = "";
    let savedSelect = "";
    let contextmenuOpen = false;
    let elementFind = false;
    let selectedElem = null;

    function deproxify(u, currentRemoteBase) {
        try {
        const abs = new URL(u, currentRemoteBase);
        if (abs.origin === server.origin && abs.searchParams.has("url")) {
            return abs.searchParams.get("url") || abs.href;
        }
        return abs.href;
        } catch { return u; }
    }

    function rewriteUrl(baseServerUrl, u, currentUrl) {
        try {
            const resolved = new URL(deproxify(u), currentUrl).href;

            if (/^(ws|wss|data|javascript):/.test(resolved)) return resolved;

            const p = new URL(baseServerUrl);
            p.searchParams.set("url", resolved);
            return p.href;
        } catch (e) {
            return u;
        }
    }

    
    function renderIntoIframe(html, remoteUrl) {
        currentUrl = remoteUrl;

        if (document.getElementById(selectedTab)) document.getElementById(selectedTab).remove();
        const frame = document.createElement("iframe");
        frame.id = selectedTab;
        frame.classList.add("page");
        document.body.append(frame);

        const doc = frame.contentDocument || frame.contentWindow.document;
        doc.open(); doc.write(html); doc.close();

        const win = frame.contentWindow;
        win.setTitle = window.setTitle;
 
        win.eval(`
        document.requestStorageAccess = async () => Promise.resolve();
        document.hasStorageAccess = async () => true;
        const titleEl = document.querySelector("title");
        if (titleEl) window.setTitle(titleEl.textContent);
        `);
        

        // SRI

        doc.querySelectorAll("link[integrity], script[integrity]").forEach(el => {
            el.removeAttribute("integrity");
            el.removeAttribute("crossorigin");
        });

        // Imports

        const origImport = frame.contentWindow?.__proto__?.import;

        win.__proto__.import = async function (path) {
            if (typeof path === "string") {
                if (!path.startsWith("http") && !path.startsWith("data:") && !path.startsWith("//")) {
                    const abs = new URL(path, win.location.href).href;
                    path = rewriteUrl(serverUrl, abs, remoteUrl);
                }
            }
            return origImport(path);
        };

        // Links
        doc.addEventListener("click", e => {
            const a = e.target.closest("a");
            if (!a) return;
            e.preventDefault();
            const rawHref = a.getAttribute("href") || a.href;
            const next = deproxify(rawHref, remoteUrl);
            loadPage(next);
        });

        // Location stuff

        win.history.pushState = () => {}
        win.history.replaceState = () => {}

        win.addEventListener("beforeunload", e => {
        const next = win.location.href;
        if (win.parent && typeof win.parent.loadPage === "function") {
            e.preventDefault();
            e.returnValue = "";
            loadPage(next);
            return false;
        }
        });

        // Forms

        const submitHandler = e => {
            const form = e.target.closest("form");
            if (!form) return;

            e.preventDefault();
            
            const rawAction = form.getAttribute("action") || "";
            const action = deproxify(rawAction || remoteUrl, remoteUrl);
            const formData = new FormData(form);
            const params = new URLSearchParams(formData);
            if ((form.method || "get").toLowerCase() === "post") {
                fetch(server.href + "?url=" + encodeURIComponent(action), {
                    method: "POST",
                    body: params,
                    headers: { "Content-Type": "application/x-www-form-urlencoded" },
                    credentials: "include"
                })
                .then(r => r.text())
                .then(html => renderIntoIframe(html, action));
            } else {
                const url = action + (action.includes("?") ? "&" : "?") + params.toString();
                loadPage(url);
            }
        };
        doc.addEventListener("submit", submitHandler, true);
        doc.querySelectorAll("form").forEach(form => {
            const nativeSubmit = form.submit;
            form.submit = function() {
                const ev = new Event("submit", { cancelable: true, bubbles: true });
                if (form.dispatchEvent(ev)) {
                    nativeSubmit.apply(form, arguments);
                }
            };
        });
        // Patch fetch
        const origFetch = win.fetch;
        win.fetch = function (input, init) {
            if (typeof input === "string") {
                input = rewriteUrl(serverUrl, input, remoteUrl);
            } else if (input instanceof Request) {
                const newReq = new Request(rewriteUrl(serverUrl, input.url, remoteUrl), {
                    method: input.method,
                    headers: input.headers,
                    body: input.body,
                    mode: input.mode,
                    credentials: input.credentials,
                    cache: input.cache,
                    redirect: input.redirect,
                    referrer: input.referrer,
                    integrity: input.integrity,
                });
                input = newReq;
            }

            return origFetch(input, init).catch(e => {
                throw e;
            });
        };

        // Patch XMLHttpRequest
        const origOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(method, url, ...rest) {
            let rewrittenUrl = url;
            try {
                rewrittenUrl = rewriteUrl(serverUrl, url, remoteUrl);
            } catch (e) {
                console.error(`rewriteUrl failed for ${url}: ${e.message}`);
            }

            try {
                return origOpen.call(this, method, rewrittenUrl, ...rest);
            } catch (e) {
                throw e;
            }
        };



        // Meta refresh
        doc.querySelectorAll('meta[http-equiv="refresh"]').forEach(meta => {
            const content = meta.getAttribute("content") || "";
            const match = content.match(/^\s*(\d+)\s*;\s*url=(.+)$/i);
            if (match) {
            const delay = parseInt(match[1], 10) * 1000;
            const raw = match[2].trim();
            const next = deproxify(raw, remoteUrl);
            setTimeout(() => loadPage(next), delay);
            }
        });

        // Location stuff

        win.open = (u) => { loadPage(deproxify(u, remoteUrl)); return null; }

        // Stuff

        const noop = () => {};

        win.addEventListener("popstate", e => {} );
        injectMutationObserver(
            win,
            serverUrl,
            remoteUrl
        );
    }
    function injectMutationObserver(targetWindow, serverUrl, targetUrl) {
        const attrMap = {
            a: "href",
            link: "href",
            img: "src",
            script: "src",
            iframe: "src",
            frame: "src",
            embed: "src",
            object: "data",
            source: "src",
            track: "src",
            audio: "src",
            video: "src",
            form: "action",
            area: "href",
        };
        const script = `
            (function() {
                const attrMap = ${JSON.stringify(attrMap)};
                const serverUrl = "${serverUrl}";
                const targetUrl = "${targetUrl}";
 

                function shouldRewrite(el) {
                    try {
                    if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;
                    if (el.hasAttribute && el.hasAttribute('data-huopa-rewritten')) return false;
                    return true;
                    } catch {
                    return false;
                    }
                }

                function markRewritten(el) {
                    try {
                    if (el.setAttribute) el.setAttribute('data-huopa-rewritten', '1');
                    } catch {}
                }

                function rewriteUrlSafe(url, serverUrl, baseUrl) {
                    try {
                    if (!url || /^(data|javascript|wss?|blob):/i.test(url)) return url;
                    const absoluteUrl = new URL(url, baseUrl).href;
                    if (absoluteUrl.startsWith(serverUrl)) return url;
                    return \`\${serverUrl}?url=\${encodeURIComponent(absoluteUrl)}\`;
                    } catch {
                    return url;
                    }
                }

                function rewriteCss(css) {
                    if (!css) return css;
                    try {
                    return css.replace(/url\\(\\s*(['"]?)(.*?)\\1\s*\\)/g, (_, quote, url) => {
                        const clean = url.trim();
                        if (/^data:/i.test(clean)) return \`url(\${url})\`;
                        return \`url(\${rewriteUrlSafe(clean, serverUrl, targetUrl)})\`;
                    });
                    } catch {
                    return css;
                    }
                }

                function rewriteElement(el) {
                    if (!shouldRewrite(el)) return;

                    if (el.tagName && el.tagName.toLowerCase() === "title") {
                    window.setTitle(el.textContent);
                    markRewritten(el);
                    return;
                    }

                    // attributes
                    try {
                    for (const [tag, attr] of Object.entries(attrMap)) {
                        if (el.tagName && el.tagName.toLowerCase() === tag) {
                        let val = el.getAttribute && el.getAttribute(attr);
                        if (val && !/^(data:|javascript:|ws:|wss:)/i.test(val)) {
                            el.setAttribute(attr, rewriteUrlSafe(val, serverUrl, targetUrl));
                        }
                        }
                    }
                    } catch { }

                    // inline styles
                    try {
                    if (el.hasAttribute && el.hasAttribute("style")) {
                        el.setAttribute("style", rewriteCss(el.getAttribute("style")));
                    }
                    } catch {}

                    // style tag contents
                    if (el.tagName && el.tagName.toLowerCase() === "style") {
                        if (el.hasAttribute("data-emotion") || el.hasAttribute("data-s")) {
                            markRewritten(el);
                            return;
                        }
                        try {
                        el.textContent = rewriteCss(el.textContent);
                        } catch {}
                    }

                    // srcset handling
                    try {
                    const tagLower = el.tagName && el.tagName.toLowerCase();
                    if (tagLower && ["img", "source"].includes(tagLower)) {
                        let srcset = el.getAttribute && el.getAttribute("srcset");
                        if (srcset) {
                        let rewritten = srcset
                            .split(",")
                            .map(entry => {
                            let [url, size] = entry.trim().split(/\s+/, 2);
                            return rewriteUrlSafe(url, serverUrl, targetUrl) + (size ? " " + size : "");
                            })
                            .join(", ");
                        el.setAttribute("srcset", rewritten);
                        }
                    }
                    } catch {}

                    markRewritten(el);
                }

                try {
                    document.querySelectorAll("*:not([data-huopa-rewritten])").forEach(rewriteElement);
                } catch {}

                const observer = new MutationObserver(mutations => {
                    const toRewrite = [];

                    for (const mutation of mutations) {
                    if (mutation.type === "childList") {
                        mutation.addedNodes.forEach(node => {
                        if (node.nodeType === Node.ELEMENT_NODE && shouldRewrite(node)) {
                            toRewrite.push(node);
                        }
                        });
                    } else if (mutation.type === "characterData" && mutation.target.parentNode?.tagName === "TITLE") {
                        window.setTitle(mutation.target.parentNode.textContent);
                    }
                    }

                    if (toRewrite.length === 0) return;

                    observer.disconnect();
                    try {
                    for (const node of toRewrite) {
                        if (shouldRewrite(node)) rewriteElement(node);
                        try {
                        node.querySelectorAll && node.querySelectorAll("*:not([data-huopa-rewritten])").forEach(rewriteElement);
                        } catch {}
                    }
                    } finally {
                    observer.observe(document.documentElement, { childList: true, subtree: true, characterData: true });
                    }
                });

                observer.observe(document.documentElement, { childList: true, subtree: true, characterData: true });

                const original = Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, "src");

                Object.defineProperty(HTMLScriptElement.prototype, "src", {
                    set(value) {
                        try {
                            const absolute = new URL(value, targetUrl).href;

                            if (!absolute.startsWith(serverUrl)) {
                                const proxied = \`\${serverUrl}?url=\${encodeURIComponent(absolute)}&pageBase=\${encodeURIComponent(targetUrl)}\`;
                                return original.set.call(this, proxied);
                            }
                        } catch (err) {
                            console.warn("[huopaproxy] script.src rewrite error:", err);
                        }

                        return original.set.call(this, value);
                    },
                    get() {
                        return original.get.call(this);
                    },
                    configurable: true,
                    enumerable: true
                });

            })();

        `;

        const scriptEl = targetWindow.document.createElement("script");
        scriptEl.textContent = script;
        try {
            targetWindow.document.body.appendChild(scriptEl);
        } catch {}
    }


    async function loadPage(rawRemoteUrl) {
        let remoteUrl = rawRemoteUrl;

        if (rawRemoteUrl === "about:blank") {
            if (document.getElementById(selectedTab)) document.getElementById(selectedTab).remove();
            return;
        }
        if (!remoteUrl.startsWith("http://") && !remoteUrl.startsWith("https://") && !remoteUrl.includes(" ") && remoteUrl.includes(".")) {
            remoteUrl = "http://" + remoteUrl;
        }
        const raw = await fetch(server.href + "?url=" + encodeURIComponent(remoteUrl), {
            credentials: 'include'
        });
        urls[selectedTab] = remoteUrl;
        const html = await raw.text();
        renderIntoIframe(html, remoteUrl);
    }
    function isValidURL(str) {
        try {
            const data = new URL(str);
            if (data.protocol.startsWith("http")) return true;
            return false;
        } catch {
            return false;
        }
    }
    window.loadPage = loadPage;
    function setTitle(content) {
        title = content;
    }
    window.setTitle = setTitle;
    loadPage(targetUrl);

    window.addEventListener("message", async (e) => {
        if (!e?.source) return;

        const type = e.data?.type
        switch (type) {
            case "openURL":
                loadPage(e.data.url);
                break;
        
            case "getTitle":
                window.parent.postMessage({ type: "getTitle", data: title }, "*");
                break;
            default:
                console.warn("Unknown data sent from parent.");
                break;
        }

        console.log(e);
    })
</script>
</body>
</html>